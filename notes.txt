# Notes

Just thought I would add some notes in as I work.
This is to just talk about code stuff, instead of adding it in comments. Ew. Gross.

Idea: This would be an awesome learning resource for others - it might help explain my thoughts on
structure if anybody else starts contributing to this.

Probably will just become an empty outdated wasteland, though.

## 2019.12.07

Working on the stupid state machine bugs revolving around Teleporting and SelectSkills.

Right now Teleporting forces the GridSystem into an explicit State (the enum) that isn't actually inferred
from the state (concept) of the tilemap and combat components.

What I would like to do is refactor the whole damn thing. Give the tilemap and combat components less power. Make them just Util function classes.
It's extremely frustrating to have to follow threads through three different classes and not be sure what influences another.

However, I'll probably just stick to making the States (enums) in the GridSystem force the inferred state in the subcomponents.

I fixed the bug without a refactor - I just was forgetting to generate the attack / move range circles when entering into the ALLY_SELECT state, even
though I would much prefer to enter into NO_SELECTION after a successful teleport. That seems like a preference thing though.

Creating a StateEnter / StateExit structure may help... but I worry about the codebloat. It might be too heavy-handed and entering / exiting behavior may
start to branch depending on the previous state. Is that bad or not? Not sure.

I fixed the State.SELECT_SKILL_ACTIVATED -> State.NO_SELECTION transition now that all tiles are cleared on entering State.NO_SELECTION.
There are still lingering "double select" allies in order to make the State.ALLY_SELECTED state actually generate the right tiles.

## 2019.12.10

In thinking about Tilemap and Combat components, I realized a couple of things:

* By "saving" steps or actions that are made by the player in object form, it will be easier to create a debuggable log of encounters later
* The Combat component is really defining what is "executed", except for the skill select flow that is pretty crudely determined by Tilemap
* Tilemap just works to display everything - no surprise that the select skill state is the most buggy right now... combat and tilemap logic aren't cohesive here

My goal right now is to extract the CombatComponent into a more "functional" class that returns Actions to the GridSystem. The TilemapComponent will help to visualize
these actions as they are executed in a more utility-like fashion.

Flow:
    GridSystem -> determines mouseTile (tile that mouse is hovering over) and when clicked:
        CombatComponent.GetUserDesignatedAction() : Action
        returnedAction.Display(tilemap) -> calls TilemapUtils
        returnedAction.Execute(combat) -> calls CombatUtils

    Action class is designated outside of GridSystem, and uses instances of tilemap and combat instead of OO-style execution

Current bugs before I pick up and go home:
* selectedEntity is not being updated in CombatComponent which leads to problems with the Move actions
  * since this shouldn't be updated in CombatComponent anyway, just gotta store it somewhere.

## 2019.12.11

On top of the CombatComponent -> StateMachineComponent change, I need to focus on restructuring even the Action / State interactions.

Perhaps there's some duplicate code that I can remove and use StateData within the Actions. Not sure yet.
Perhaps a better name for Actions would be Transitions, as they are the functions that execute when the
StateMachine moves from one state to another.

I think the goal that separates the StateMachineComponent from the state machine switch case in GridSystem is the following:
1. The GridSystem focuses on forwarding user input
2. The StateMachineComponent focuses on determining current conditions and figuring out what logic needs to be executed under those conditions.

## 2019.12.13

Realized that the SkillSelectTile action/transition should still be one, as "move" and "attack" are transitions yet stay within
the same state.

This is growing to be quite a large change and I think I'm getting a bit lost in the details. I'll see what I can manage to finish by
the end of Saturday morning. I'll hold off on the simplification of the Action/Transition class for now. What I would like to do there is:
* Reduce the number of member variables in an action, instead keep that data in the StateData objects that will be passed in
* Reduce the call in GridSystem to just currentState = stateMachine.Transition(currentState); instead of Execute, Display, etc.
  * Those Display and Execute methods will still help the readability and structure, but they'll work only within the Action/Transition objects

## 2019.12.14

I reduced the StateType / StateData classes into a single State class - since the type of the subclass explicitly specifies the StateType.

## 2019.12.18

Noticing some bugs with skill deactivation, but everything is now "functional". I think I'll still scan through the remainder
of the code to clean it up before the end of the year, so it's unlikely that I'll get many features implemented before 2020. That should be okay.

Gonna make a commit a bit early just to nail down the new structure, and then will fix bugs, and finally will clean everything out.

Now I'm working on picking out some stuff from StateMachineComponent and making sure that Actions don't contain any data that States do not.

Just realized that logging the actions taken (along with saving AI choices), I can create an event log to replay encounters. Creating a headless
encounter replayer would be a fabulous way to write integration tests TBH. That could be very very helpful.

Bug: Deactivating a select tiles skill still uses the SP needed for the skill.

## 2019.12.19

I'm working on removing the SelectedTile class from TilemapComponent and making functions static where possible. This means that the Action
and State classes may change a bit to store the data that is being extracted from the Tilemap singleton.

Creating that headless encounter replayer sounds like a really helpful and interesting tool, but I'll do my best to save that work until
after the initial prototype is done.

This whole refactor project is teaching me that I should attempt to limit the number of singleton objects as much as possible. Initially,
creating a state machine that had objects representing the state's data and FSM's edges seemed like a lot of work. But it is a lot cleaner
to write it out that way than to modularize the "model" and "view" aspects into their own singletons. Not sure if this could be applied
to non-tactics / turn-based games, but I do think this has proved valuable right now.

I'm finding that I want to put single objects like the grid or factions into states. I'm wondering what kind of computation it would take to
constantly transfer this info from state to state. I don't think it would recreate the objects over and over, so it'd be just passing it via reference.
Would the old states that still refer to that data be garbage collected? I'm really not sure.

There's a lot of duplicate code across Actions right now... especially when it comes to displaying tile ranges for characters.
That being said, I feel like it's better to minify it as much as possible without extracting these calls into a "common flow" like an inherited
before/after method for different skills. It would only stand to make it more confusing, I think. Actions shouldn't be chained or extended IMO.

Going to make a commit tonight for removing the moveRange and attackRange lists from TilemapComponent, will remove the others later.

## 2019.12.28

Working on the Teleportation behavior and I need to make sure that enemies can "delay" a turn, or kind of "queue" up multiple turns in a row. As in,

Player Turn 1: Player does something, then ends turn
Enemy Turn 1: Enemy begins teleportation phase
Player Turn 2: Player does something, then ends turn
Enemy Turn 2: Enemy teleports, then does something else

I guess in a sense, the "teleport" could be considered a "pre-turn", as the enemies will still need to determine what to do *after*
they've teleported. Or, better yet, can they react to what the player has done on Turn 2?

I think that a fleeing teleport would be better to allow the player to "outsmart" the enemy by predicting where they go.
So the enemy should determine the area they want to teleport in Enemy Turn 1, then re-calculate their next move in Enemy Turn 2.

On the other hand, an offensive teleport would be better to calculate the teleporting place in Enemy Turn 2. Allowing both would be a good design
pattern, and perhaps some enemies pre-calculate or post-calculate teleports depending on their canonical way of teleporting.

Right now, I want to be able to pass an AIStep, whether pre-calculate or post-calculate, into the next EnemyTurn state data. And since I designed state data
to not be saved after a state transition... there may be a problem there.

Working through the possible options of where to store the "rolled over" behavior for an AI:

### 1. GridSystem
Probably not a good idea, as I don't feel this should store anything beyond the currentState for a given AI entity or turn

### 2. GridEntity
Could be a possibility, but how to store it?

#### A. Behavior (member variable "state")
I want behaviors to be something like Actions for the StateMachine, where they are purely functional and don't carry their own state.
That being said, each AI has a specific Behavior object, so it's possible this state could be stored in a behavior. Since each behavior is
"evaluated" when iterating through each one to determine a score, it's possible to score this one extremely high if it was already "queued" for the next turn.
On top of that, it would allow a player's actions in a specific turn to "break" an enemy's "queued" up turn.

Imagine a duo boss fight where there is one "strong" enemy and one "healer" enemy. Perhaps the strong enemy will queue up a powerful attack
that is unblockable by common means. However, if the player attacks the healer enemy during the strong enemy's "windup", the strong enemy will
cancel the move to come to the healer's rescue. This could be a very interesting tactic... so maybe force a score somehow.

even something as simple as `if (lastTurnBehavior == this), boost final score` would work here.

Now the question becomes: where should the lastTurnBehavior be stored?

I decided that GridEntity would be the best place for it because:
* It's very easy to store there from the actual DoBestAction method
* It's not "acted" on but merely kept for reference (for now at least...)

## 2020.01.01

Working on the EvasiveTeleport behavior. I decided that it should only work as a "spacing" behavior, not as a "fleeing" one.

In essence, the "higher up" elk cultists might use EvasiveTeleport to get away from the party and heal.
The minions may use a different Behavior like FleeingTeleport where they immediately disappear after a single turn of teleport queueing.

However, right now, the EvasiveTeleport will outweigh the MeleeAttackV1 (in the current ShamblingCorpse enemy) whenever the party is not within "range".
So MeleeAttackV1 will need some tweaks, but not in this commit. Only thing I'll do is bump up the health boosting, or add another section to quash
the total score when the enemy is at full health.
